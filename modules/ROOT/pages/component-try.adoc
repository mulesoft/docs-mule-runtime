// Filenames follow a syntax component-some-name.adoc
// So for component-scatter-gather.adocs, the confugration is
// :component-filename: scatter-gather
:component-filename: try
:page-aliases: try-scope-concept.adoc, try-scope-xml-reference.adoc
//:page-deployment-options: cloud-ide, desktop-ide

//TBD if this is needed for changing singular to plural 
:example: example

//
//title of this page
include::anypoint-code-builder::partial$mule-components/4.x/component-{component-filename}.adoc[tag=component-title]
//

//INTRODUCTION
//short description
include::anypoint-code-builder::partial$mule-components/4.x/component-{component-filename}.adoc[tag=component-short-description]
//
//long description, if needed
include::anypoint-code-builder::partial$mule-components/4.x/component-{component-filename}.adoc[tag=component-long-description]
//

//TODO: REVIEW ADDITION from MULE DOCS
== Try Scope Structure

A Try scope has the following structure:


* A single root element `<try/>`

* Components that are executed under the error-handling rules defined by
the Try scope are defined as child elements of the `try` element. You can place one or many here.

* A single `<error-handler/>` element holds all error handling strategies for the scope.

* In the error handler, one or several `on-error-continue` and `on-error-propagate` define the various strategies. At least one of these error handling components must be present.

* Components that are executed when a matching error occurs are defined as child elements of the `on-error` element. You can place one or many here.

[source,xml,linenums]
----
<try>
  <!-- COMPONENTS TO TRY TO USE -->
  <error-handler>
    <on-error-continue>
      <!-- COMPONENTS TO USE IN CASE OF ERROR -->
    </on-error-continue>
    <on-error-propagate>
      <!-- COMPONENTS TO USE IN CASE OF ERROR -->
    </on-error-propagate>
  </error-handler>
</try>
----

Each error handling strategy in a Try scope (`on-error-*`) follows a condition. This condition is typically an error type (or a list of several) which must match the current error. You can also define this condition as a freely written expression, such as `error.cause.message.contains("fatal")`.

[NOTE]
Note that conditions are evaluated in order and only the first strategy to match is executed.

The following example includes two error handling strategies, each executing a logger component:


[source,xml,linenums]
----
<try>
  <http:request config-ref="HTTP-config" method="GET" path="/" />
  <error-handler>
    <on-error-continue enableNotifications="true" logException="true" type="CONNECTIVITY">
      <logger level="INFO" doc:name="Logger" message="Connectivity Error"/>
    </on-error-continue>
    <on-error-propagate enableNotifications="true" logException="true" doc:name="On Error Propagate" type="EXPRESSION">
      <logger level="INFO" doc:name="Logger" message="Expression error" />
    </on-error-propagate>
  </error-handler>
</try>
----

//
//COMPONENT XML AND SNIPPET SECTION
//component XML title
include::anypoint-code-builder::partial$mule-components/4.x/component-{component-filename}.adoc[tag=component-xml-title]
//
//component XML
include::anypoint-code-builder::partial$mule-components/4.x/component-{component-filename}.adoc[tag=component-xml]
//
//component XML variant, as needed
//TODO_INTRO_AS NEEDED
//include::anypoint-code-builder::partial$mule-components/4.x/component-{component-filename}.adoc[tag=component-xml2]
//
//

//
//Component element and attribute descriptions
include::anypoint-code-builder::partial$mule-components/4.x/component-{component-filename}.adoc[tag=component-xml-attributes-root]
//
// component SNIPPET JSON, if available:
//include::anypoint-code-builder::partial$mule-components/4.x/component-{component-filename}.adoc[tag=component-snippet-json]
//

//Child Element (if needed, repeating as necessary): 
//Component element and attribute descriptions
//include::anypoint-code-builder::partial$mule-components/4.x/component-{component-filename}.adoc[tag=component-xml-attributes-child1]
//
//Grandchild/Descendant Element (if needed, repeating as necessary): 
//Component element and attribute descriptions
//include::anypoint-code-builder::partial$mule-components/4.x/component-{component-filename}.adoc[tag=component-xml-attributes-descendant1]
//

//TODO: REVIEW ADDITION from MULE DOCS
== Variable and Payload Propagation

Every payload modification or variable addition, modification, or removal is propagated through the rest of the execution. This propagation includes modifications that take place inside the error handlers.

//TODO: REVIEW ADDITION from MULE DOCS
== Configuring Local or XA Transactions

In addition to configuring the Transactional Action, you can also configure the Transaction Type to be Local (single Resource) or XA Transaction.

The Try scope uses the Transaction Type configuration only when a new transaction is created. The type cannot change while a transaction executes.

For each Transactional Action, the behavior changes:

* Ignore (`INDIFFERENT`)
+
The Transaction used is the one already created (if there is one). This means that setting the Transactional Type makes no difference for this Transactional Action.
* Always Begin (`ALWAYS_BEGIN`)
+
The Transaction created is of the type set in the Transaction Type configuration. Remember that `ALWAYS_BEGIN` is an invalid configuration when already running within a Single Resource transaction.
* Begin or Join (`BEGIN_OR_JOIN`)
+
If there is a Transaction already created, then the Transactional Type makes no difference, as in the case of `INDIFFERENT`. If there is no Transaction, it creates one of the Type configured in Transaction Type, as in the case of `ALWAYS_BEGIN`.

// 
//EXAMPLES SECTION
//example: title (Examples)
include::anypoint-code-builder::partial$mule-components/4.x/component-{component-filename}.adoc[tag=component-examples-title]
//
//example: generic intro
include::anypoint-code-builder::partial$mule-components/4.x/component-{component-filename}.adoc[tag=component-examples-intro]

//
//XML example
include::anypoint-code-builder::partial$mule-components/4.x/component-{component-filename}.adoc[tag=component-xml-ex1]
//
//
//XML example 2, if needed
include::anypoint-code-builder::partial$mule-components/4.x/component-{component-filename}.adoc[tag=component-xml-ex2]
//
//XML example 3 if needed
include::anypoint-code-builder::partial$mule-components/4.x/component-{component-filename}.adoc[tag=component-xml-ex3]
//

// STUDIO Example (not shared)
//TODO: REVIEW ADDITION from MULE DOCS
=== Example: Try Scope Configuration

In the following example, any database connection errors (`DB:CONNECTIVITY`) are propagated because of the On Error Propagate (`on-error-propagate`) error handler. Propagation of this error causes the Try scope's execution to fail and the flowâ€™s error handler to execute. Other errors are handled through the On Error Continue (`on-error-continue`) error handler, so the Try scope's execution is treated as successful when they occur, meaning that the next operation, an HTTP request, continues its execution.

Configuration example in Anypoint Studio:

image::error-handling-try-scope.png[Error Handling with the Try Scope]
//TODO: Consider showing the same in ACB.

If the Try scope has several components, then after a component raises an exception, subsequent components in the Try scope are not executed, regardless of the type of error handler that catches the exception. In the case of On Error Propagate, the error is propagated to the flow's error handler, as if the Try scope did not exist. In the case of On Error Continue, processing continues outside the Try scope at the next flow component, as if the Try scope never threw an exception.

//
//ERROR HANDLING SECTION, if available
include::anypoint-code-builder::partial$mule-components/4.x/component-{component-filename}.adoc[tag=component-error-handling]
//

//SEE ALSO SECTION, if needed
include::anypoint-code-builder::partial$mule-components/4.x/component-{component-filename}.adoc[tag=see-also]
//