= For Each Scope
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:page-aliases: for-each-scope-xml-reference.adoc

Processing within the For Each scope (`<foreach />`) is similar to a `for-each` or `for` loop in most programming languages.

By default, For Each splits the `payload` it receives as input into separate elements and processes them one by one or within separate batches containing a configured number of elements. Alternatively, you can use a DataWeave expression to collect a portion of the input to split (such as, `payload._someField_`). The scope accepts collections, including lists and arrays, of any supported content type, such as `application/json`, `application/java`, or `application/xml`.

Within the scope, each element or batch of elements is treated as a separate `payload`. Instead of outputting processed input, the scope outputs the entire Mule event that it received as input, along with any additional Mule variables created within the scope. The input event includes the un-split payload, attributes of the payload, and any Mule variables associated with the event. By default, the scope stores that event in a variable (`rootMessage`) that you can access from within For Each. Note that For Each consumes this variable, so it is not available outside For Each.

The scope's splitter ignores attributes of the input to For Each. These attributes are metadata in the Mule message, such as the content type or status code in a response to an HTTP request. Mule attributes are not accessible from the split elements, so `attributes` returns `null` from within For Each. However, you can use the For Each variable `rootMessage` to access the attributes from within For Each, for example, with  `vars.rootMessage.attributes."content-type"` to return a content type such as `application/json; charset=utf-8` from the header attributes of an HTTP response.

Unlike attributes in the Mule message, Mule variables are directly accessible within For Each using the `vars` selector, such as `vars._someVariable_`. See <<variable_propagation, Variable Propagation>> to understand how modifications to values of Mule variables propagate from within and outside of the For Each component.

[[example]]
== Basic Flow With For Each

The following example illustrates a basic flow with For Each in Anypoint Studio. Assume that the scope receives its input from a scheduled HTTP request for this https://jsonplaceholder.typicode.com/users[JSON array of objects].

[[studio_example]]
image::mruntime-component-foreach-example.png[For Each Component]

As the following XML for this example shows, For Each (`<foreach />`) collects and splits the entire array (`payload`) it receives into separate objects. Components within the scope select a portion of each object, write a portion of that selected content into separate files, and log the new `payload` that results within For Each.

[source,xml]
----
<!-- 1: For Each -->
<foreach doc:name="For Each"  collection="#[payload]">
  <!-- 2. Transform Message -->
  <ee:transform doc:name="Transform Message" >
    <ee:message >
      <ee:set-payload ><![CDATA[%dw 2.0
output application/json
---
payload.company]]></ee:set-payload>
    </ee:message>
  </ee:transform>
  <!-- 3. File Write -->
  <file:write doc:name="Write"
    path='#[(payload.name replace " " with("-") ++ "-") ++ (now() as String {format: "uuuuMMddHHmmss"}) ++ ".json"]'
    config-ref="File_Config" mode="CREATE_NEW"/>
  <!-- 4: Logger -->
  <logger level="INFO" doc:name="Logger" message="#[payload]"/>
</foreach>
----

. For Each (`<foreach />`) collects the entire input payload and splits it into the ten top-level JSON objects within it, such as this one:
+
[source,json]
----
{
  "id": 1,
  "name": "Leanne Graham",
  "username": "Bret",
  "email": "Sincere@april.biz",
  "address": {
    "street": "Kulas Light",
    "suite": "Apt. 556",
    "city": "Gwenborough",
    "zipcode": "92998-3874",
    "geo": {
      "lat": "-37.3159",
      "lng": "81.1496"
    }
  },
  "phone": "1-770-736-8031 x56442",
  "website": "hildegard.org",
  "company": {
    "name": "Romaguera-Crona",
    "catchPhrase": "Multi-layered client-server neural-net",
    "bs": "harness real-time e-markets"
  }
}
----
. As For Each iterates over each object, the DataWeave expression (`payload.company`) in the xref:transform-component-about.adoc[Transform Message] component (`<ee:transform />`) uses DataWeave selectors to extract the value of each `"company"` key and transform the `payload` to the value of each of those keys. As in a Mule flow, the next component within For Each receives the transformed payload as its input.
. The File Write operation (`<file:write />`) uses `payload.name` within a larger DataWeave expression to select the `name` of each company from the transformed object. The name of each file follows the pattern specified in the expression, which hyphenates the extracted company name and appends a date-time stamp to make the file name unique. For example, the name of a file for Abernathy Group data looks like this:
+
[source,log]
----
Abernathy-Group-20221007113314.json
----
By default, the operation also loads the payload received from Transform Message to each file, for example:
+
[source,log]
----
{
  "name": "Abernathy Group",
  "catchPhrase": "Implemented secondary concept",
  "bs": "e-enable extensible e-tailers"
}
----

For configurable For Each properties, see <<reference>>.

== Use Cases and Examples

You can learn more about using For Each from several Mule projects within https://www.mulesoft.com/exchange/[Anypoint Exchange^]:

* _Authenticating Salesforce using OAuth2_
* _Import contacts into Microsoft Dynamics CRM_
* _Importing a CSV file into mongoDB_
* _Importing an Email Attachment using the IMAP Connector_
* _Importing Email Attachments using the POP3 Connector_
* _Querying a Database and Attaching Results to an Email_

You can also open these projects from xref:studio::import-project-exchange.adoc[Anypoint Studio].

[[variable_propagation]]
== Variable Propagation

Each execution within For Each begins with the values of Mule variables
from the previous execution. New Mule variables or modifications to the values of existing variables that take place when processing one element are accessible during the processing other elements. Changes to Mule variables continue to be available outside the For Each scope.

[source,xml]
----
<set-variable variableName="var1" value="var1-BeforeForEach"/>
<set-variable variableName="var2" value="var2-BeforeForEach"/>
<foreach collection="#[['apple', 'banana', 'orange']]">
    <choice>
        <when expression="#[payload == 'apple']">
            <set-variable variableName="var2" value="var2-newValue"/>
            <set-variable variableName="var3" value="var3-appleVal"/>
        </when>
        <when expression="#[payload == 'banana']">
            <set-variable variableName="var3" value="#[vars.var3 ++ ' bananaVal']"/>
            <!-- var3 will now have value 'var3-appleVal bananaVal'-->
        </when>
        <otherwise>
            <set-variable variableName="var3" value="var3-otherVal"/>
            <set-variable variableName="var4" value="var4-val4"/>
        </otherwise>
    </choice>
    <logger level="INFO" doc:name="Logger After Choice"
            message='#[ [vars.var1, vars.var2, vars.var3, vars.var4] as Array ]'/>
</foreach>
<logger level="INFO" doc:name="Logger After For Each"
         message='#[[vars.var1, vars.var2, vars.var3, vars.var4] as Array]'/>
----

As the xref:choice-router-concept.adoc[Choice router] (`<choice />`) executes the processors within each condition, the Logger (`Logger After Choice`) prints the following variable values:

[source,log]
----
// Condition: when payload == 'apple'
.LoggerMessageProcessor:
[var1-BeforeForEach, var2-newValue, var3-appleVal, null]

// Condition: when payload == 'banana'
.LoggerMessageProcessor:
[var1-BeforeForEach, var2-newValue, var3-appleVal bananaVal, null]

// Condition: otherwise
.LoggerMessageProcessor:
[var1-BeforeForEach, var2-newValue, var3-otherVal, var4-val4]
----

The last values are propagated outside of For Each. The logger (`Logger After For Each`) prints the same values as the ones printed after the final choice condition (`otherwise`).

[source,log]
----
[var1-BeforeForEach, var2-newValue, var3-otherVal, var4-val4]
----

== Error Handling

If one of the elements in a collection throws an exception, For Each stops processing that collection and invokes the error handler.

See xref:on-error-scope-concept.adoc[] for information about Mule error handlers.

[[reference]]
== Reference

The For Each scope (`<foreach/>`) provides a number of configurable properties:

[%header,cols="1a,1a,1a,4a"]
|===
| Field Name | XML | Default | Description

| *Collection*
| `collection`
| `payload`
| A DataWeave expression that returns a Java collection, object, array, map, or DOM nodes. For Each automatically splits the collection into elements, such as the highest-level objects in a JSON array of objects. Each element becomes the `payload` on which a processor within For Each acts. For Each accepts collections of any supported content type, such as `application/json`, `application/java`, or `application/xml`.

| *Counter Variable Name*
| `counterVariableName`
| `counter`
| Name of the variable that assigns a number to each iteration over a given element. The sequence starts with `1` and proceeds sequentially. Using the default name of this property (`counter`), you can access this number with `vars.counter`. For Each consumes this variable, so it is not available and returns `null` when used outside of the scope.

| Batch Size
| `batchSize`
| `1`
| Number that the scope uses to partition the collected elements from the input into sub-collections of a specified size. For example, if input to For Each is an array of 199 elements and you set the batch size to 50, the scope produces three arrays of 50 elements each and one array of 49 elements.

| *Root Message Variable Name*
| `rootMessageVariableName`
| `rootMessage`
| Configurable name of the variable that stores the complete, un-split Mule message from the original input to For Each. The message contains the payload and any attributes but does not contain any variables (`vars`), which are part of the Mule event that contains the Mule message. Within For Each, you can gain access to the value of the payload of the message with `vars.rootMessage.payload` and to attributes of the message with `vars.rootMessage.attributes`. For Each consumes this variable, so you can access it only from within the scope. Outside For Each, the variable returns `null`.
|===

The following example illustrates the use of several attributes that are available to For Each:

[source,xml]
----
<http:request-config name="HTTP_Request_configuration"
      doc:name="HTTP Request configuration"  >
</http:request-config>
<file:config
      name="File_Config" doc:name="File Config"  >
  <file:connection
        workingDir="/Users/me/Documents/reports-example" />
</file:config>
<flow name="example-for-each-flow"  >
  <scheduler doc:name="Scheduler"  >
    <scheduling-strategy >
      <fixed-frequency frequency="1" timeUnit="HOURS"/>
    </scheduling-strategy>
  </scheduler>
  <!-- HTTP request for a JSON array of objects -->
  <http:request method="GET" doc:name="Request"
        config-ref="HTTP_Request_configuration"
        url="https://jsonplaceholder.typicode.com/users"/>
  <!-- 1: For Each -->
  <foreach doc:name="For Each" collection="payload.company">
    <!-- 2: Logger 1 -->
    <logger level="INFO" doc:name="Logger 1"
            message="#[iterationCounter : vars.counter]" />
    <!-- 3: Logger 2 -->
    <logger level="INFO" doc:name="Logger 2"
             message="#[sharedStatusCode : vars.rootMessage.attributes.statusCode]" />
    <!-- 4: File Write -->
    <file:write doc:name="Write"
          path='#[(payload.name replace " " with("-") ++ "-") ++ (now() as String {format: "uuuuMMddHHmmss"}) ++ ".json"]'
          config-ref="File_Config" mode="CREATE_NEW">
    </file:write>
    <!-- 5: Logger 3 -->
    <logger level="INFO" doc:name="Logger 3"
            message="#[vars.rootMessage.payload..company.name]"/>
  </foreach>
  <!-- 6: Logger 4 -->
  <logger level="INFO" doc:name="Logger 4"
          message="#[payload..company.name]"/>
  <!-- 7: Logger 5 -->
  <logger level="INFO" doc:name="Logger 5"
        message="#[attributes.statusCode]"/>
</flow>
----

After an HTTP request (`<http:request />`), the remaining components in the flow are configured to illustrate how For Each properties work and how access to the `payload` and `attributes` takes place within and outside of For Each:

. For Each collects company objects (`collection="payload.company"`) from the JSON array returned from the HTTP request's `url`. For Each iterates over each of these objects.
. In Logger 1, `iterationCounter : vars.counter` returns an object with the iteration number, starting with `1` for the first company object and ending with `10` for the last, for example, `{iterationCounter=1}`.
. In Logger 2, `sharedStatusCode : vars.rootMessage.attributes.statusCode` retrieves the value of the status code attribute that is stored in the `rootMessage` variable: `{sharedStatusCode=200}`. The status code comes from the original input to For Each and is not included in the split payload, so the Logger prints the same status code during each iteration of For Each.
. In `<file: write />`, the DataWeave expression extracts the value of the `payload.name` from each company object, hyphenates, and appends a unique date-time stamp to the transformed company name. Examples of names of files created by the expression are `Abernathy-Group-20221007120752.json` for the first company and `Yost-and-Sons-20221007120752.json` for the last.
+
For the file content, the setting uses the default (`payload`) implicitly, so the created files contain company data in JSON format, such as the following data for the first company object:
+
[source,log]
----
{
  "name": "Abernathy Group",
  "catchPhrase": "Implemented secondary concept",
  "bs": "e-enable extensible e-tailers"
}
----
. In Logger 3: `vars.rootMessage.payload..company.name` retrieves an array of company name values stored in the `rootMessage` variable. Like the `statusCode` value, this data is part of the original, un-split input to For Each that is stored in the `rootMessage` variable. All company names are accessible from that variable, so they can all be listed in the array.
+
[source,log]
----
[Romaguera-Crona, Deckow-Crist, Romaguera-Jacobson, Robel-Corkery,
 Keebler LLC, Considine-Lockman, Johns Group, Abernathy Group,
 Yost and Sons, Hoeger LLC]
----
. Logger 4 is located outside For Each. The expression `payload..company.name` in this logger produces the same array produced by Logger 3, but Logger 4 is able to select `payload` directly. For Each consumes the `rootMessage` variable, so the expression `vars.rootMessage.payload..company.name` from Logger 4 logger would return `null`.
. Logger 5 is located outside For Each. The expression `attributes.statusCode` produces the same status code value as the expression in Logger 2, but Logger 5 is able to select `attributes` directly. For Each consumes the `rootMessage` variable, so the expression `vars.rootMessage.attributes.statusCode` from Logger 5 would return `null`.

The next example illustrates the batch size (`batchsize`) functionality. Assume that the flow collects its input payload from the preceding flow through a Flow Reference (`<flow ref />`) component:

[source,xml]
----
<flow name="example-for-each-flow" >
  ...
  <!-- 1: Flow Reference sends Mule event to next flow. -->
  <flow-ref doc:name="Flow Reference" name="for-each-batchExample"/>
</flow>
<flow name="for-each-batchExample" >
  <!-- 2: For Each >
  <foreach doc:name="For Each"
               collection="#[payload]"
               batchSize="3">
    <!-- 3: Logger >
    <logger level="INFO" doc:name="Logger"
            message="#[payload.id]"/>
  </foreach>
</flow>
----

. The Flow Reference component sends its Mule event to next flow (`for-each-batchExample`). This event contains a JSON array of objects as its `payload`. This `payload` originated from the HTTP request in the previous flow (`example-for-each-flow`).
. For Each (`<foreach />`) in this flow (`for-each-batchExample`) sets the batch size `batchSize="3"`.
. The Logger in this flow prints the `id` values of the input (`payload.id`) in batches of 3. Each batch is an array of up to 3 elements. Because there are only 10 elements from the split input to For Each, the Logger prints the following:

[source, log]
----
...LoggerMessageProcessor: [1, 2, 3]
...LoggerMessageProcessor: [4, 5, 6]
...LoggerMessageProcessor: [7, 8, 9]
...LoggerMessageProcessor: [10]
----

== See Also

* xref:about-mule-event.adoc[]
* xref:about-mule-message.adoc[]
* xref:dataweave::dw-functions.adoc[]
* xref:parallel-foreach-scope.adoc[]
* xref:file-connector::file-write.adoc[]
* xref:http-connector::http-request-ref.adoc[]
