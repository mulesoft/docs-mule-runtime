= Parallel For Each Scope
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: anypoint studio, studio, mule, split, aggregate, scope, parallel, for, each


The Parallel For Each scope enables you to process a collection of messages by splitting the input payload into parts that are simultaneously processed in separate routes. This scope ignores Mule attributes from the input, and any creation or processing of Mule variables in within the scope do not propagate outside of the scope.
//TODO: "within the scope of any limitation configured for concurrent-processing" confusing here. break up sentence?
//TODO: NEW SENTENCE ...
within the scope of any limitation configured for concurrent-processing. After all messages are processed, the results are aggregated in the same order they were in before the split, and then the flow continues.

== Considerations

* Parallel For Each buffers the results of all processing routes in a list to return after the scope finishes processing, which can cause out-of-memory errors when processing a high number of entries. To process large payloads, use xref::batch-processing-concept.adoc[Batch Processing] instead.
* Anypoint Studio versions prior to 7.6 do not provide this feature in the Mule Palette view. To use Parallel for Each in those versions, you must manually configure Parallel For Each scope in XML.

== Reference

The Parallel For Each scope provides the following configurable fields:

[%header,cols="1a,1a,3a"]
|===
|Child element | XML | Description
|Collection | `<collection />` | DataWeave expression that defines the collection of parts to process in parallel. By default, the collection is the incoming payload.
|===

[%header,cols="1a,1a,3a"]
|===
|Attribute | XML | Description
|Collection Expression | `collection` | DataWeave expression that returns a collection. By default, the payload is treated as the collection to split.
|Timeout | `timeout` | A timeout in milliseconds for each parallel route. By default, there is no timeout.
|Max Concurrency | `maxConcurrency` | Maximum level of parallelism for the router to use. By default, all routes run in parallel. //TODO: ANY RECOMMENDATIONS FOR PERFORMANCE?
|Target Variable | `target` | Name of a variable to use for storing the Mule message (payload and any attributes) after processing by For Each. See xref:target-variables.adoc[]. 
|Target Value | `targetValue` | A DataWeave expression to evaluate against the Mule message that For Each returns. The result of this expression is stored in the target variable and accessible from a processor _after_ For Each. You can access the target variable using `vars`, for example, `vars._myTargetVariable_`. Within For Each, any attempt to access a target variable returns `null`. By default, if you leave this field blank, the target value is the Mule message created from the For Each output. 
|===

== Example

This XML example adds to every element in the collection the string `"-result"`:

[source,xml,linenums]
----
<flow name="myFlow">

  <parallel-foreach collection="#[['apple', 'banana', 'orange']]">
      <set-payload value="#[payload ++ '-result']"/>
      <logger level="INFO" doc:name="Logger" message="#[payload]" />
  </parallel-foreach>

</flow>
----

The Logger output looks like this (edited for readability): 

[source,logs]
----
INFO  ...LoggerMessageProcessor: orange-result
INFO  ...LoggerMessageProcessor: banana-result
INFO  ...LoggerMessageProcessor: apple-result
----

Every execution of the Parallel For Each scope starts with the same variables and variable values. 

//TODO: CLARIFY THIS:
New variables or modifications of already existing variables while processing one element are not visible while processing another element. All of those variable changes are not available outside the Parallel For Each scope, the set of variables (and their values) after the execution of the Parallel For Each Scope remains the same as before the execution.

// Variables created or modified within For Each 
// Changes that take place to variables within the scope are not available outside of the scope. 
// 


Consider the following example:

[source,xml,linenums]
----
<flow name="myFlow">

  <set-variable variableName="var1" value="var1"/>
  <set-variable variableName="var2" value="var2"/>
  <parallel-foreach collection="#[['apple', 'banana', 'orange']]">
      <choice>
          <when expression="#[payload == 'apple']">
              <set-variable variableName="var2" value="newValue"/>
              <set-variable variableName="var3" value="appleVal"/>
          </when>
          <when expression="#[payload == 'banana']">
              <set-variable variableName="var3" value="bananaVal"/>
          </when>
          <otherwise>
              <set-variable variableName="var3" value="otherVal"/>
              <set-variable variableName="var4" value="val4"/>
          </otherwise>
      </choice>
  </parallel-foreach>

</flow>
----

After aggregation, the variables are:

`{var1: "var1", var2: "var2"}`

None of the modifications done inside the Parallel For Each scope are registered, including the creation of new variables.

== Error Handling

Because every route is processed in parallel, if an error is thrown in one route, processing continues in all of the other routes until all finish processing. After that, all results (and any errors) are aggregated and then processed by the xref:intro-error-handlers.adoc[Error Handler], as shown here:

[source,xml,linenums]
----
<flow name="myFlow">

  <parallel-foreach collection="#[['banana', 'apple']]">
      <choice>
          <when expression="#[payload == 'banana']">
              <!-- Processor that throws error -->
          </when>
          <otherwise>
              <set-payload value="#[payload ++ '-result']"/>
          </otherwise>
      </choice>
  </parallel-foreach>
  <error-handler>
      <on-error-continue type="COMPOSITE_ROUTING">
          <!-- This will have the error thrown by the above processor -->
          <logger message="#[error.errorMessage.payload.failures['0']]"/>
          <!-- This will be a null value -->
          <logger message="#[error.errorMessage.payload.failures['1']]"/>
          <!-- This will be a null value -->
          <logger message="#[error.errorMessage.payload.results['0']]"/>
          <!-- This will have the result of this (correctly executed) route -->
          <logger message="#[error.errorMessage.payload.results['1']]"/>
      </on-error-continue>
  </error-handler>

</flow>
----

=== Throws

* `MULE:COMPOSITE_ROUTING`

include::partial$parallelforeach_vs_foreach.adoc[]

== See Also

* xref:for-each-scope-concept.adoc[For Each Scope].
* xref:transaction-management.adoc#tx_scopes_routers[How Transactions Affect Scopes and Routers]
