= Try Scope
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
//:page-aliases: try-scope-xml-reference.adoc

The Try scope (`<try />`) sequentially executes one or more connector operations or Mule components (processors) that you add to the scope.

The Try scope enables transaction management and error handling for processing within the scope. xref:transaction-management.adoc[Transactions] force a group of processors to succeed or fail as a unit. The scope accepts xref:xa-transactions.adoc[Extended Architecture (XA)] and, by default, xref:single-resource-transaction.adoc[Local (LOCAL)] transactions.

The Try scope's error handling capability is useful for components, such as the xref:for-each-scope-concept.adoc[For Each scope], that do not propagate errors to the flow's error handler and within other components, such as xref:flow-component.adoc#subflow-configuration[Subflow], that do not provide their own error handler. The Try scope can also help you isolate errors that occur within error-prone operations.

[[architecture]]
== Architecture

The Try scope has the following XML structure:

[source,xml,linenums]
----
<try>
  <!-- COMPONENTS TO TRY TO USE -->
  <error-handler>
    <on-error-continue>
      <!-- COMPONENTS TO USE IN CASE OF ERROR -->
    </on-error-continue>
    <on-error-propagate>
      <!-- COMPONENTS TO USE IN CASE OF ERROR -->
    </on-error-propagate>
  </error-handler>
</try>
----

* The scope's root element `<try />` has configurable attributes described in <<reference>>.

* Components that execute under the scope's error handling rules are child elements of `<try />`. You can place one or many components within the Try scope.

* A single `<error-handler>` element holds all error handling strategies that you define for the scope.

* Within the error handler, define the strategies within one or more On Error Continue (`<on-error-continue />`) and On Error Propagate (`<on-error-propagate />`) error handlers. On Error Propagate (`<on-error-propagate />`) is the default for any (`ANY`) error type.

* Components and operations that you add as children to On Error components execute when a matching error that you configure (such as `ANY` or `DB:CONNECTIVITY`) occurs within the Try scope.

See <<error_handling>> for more information about Mule error handling components.

[[transactions]]
== Managing Transactions

//TODO: DO WE HAVE A LIST OF COMPONENTS AND OPERATIONS THAT SUPPORT TRANSACTIONS
//TODO: Does the Set Transaction Id component have
//      anything to do with these transactions?
//      https://docs.mulesoft.com/mule-runtime/4.3/set-transaction-id
//TODO: HOW TO TELL IF A COMPONENT IS TREATED AS PART OF THE TRANSACTION?
//TODO: CAN A COMPONENT W/O A TRANSACTIONAL ACTION OPTION be part of a transaction?

A transaction is a series of actions that fail or succeed as a group. If the execution of one component or operation that is part of the transaction fails, the entire transaction fails. A transaction can be Local (single resource) or an XA transaction. XA transactions can group a series of operations from different transactional resources, such as VM, JMS, or Database operations, into a single, reliable global transaction.
//TODO: WHAT DOES COMMIT MEAN? COMMITS WHERE?
Success or failure depends on whether the errors propagate and roll back the transaction, or whether an error handler commits the transaction. For configuration options, see <<reference>>.
//TODO: Really continues? Propagate doesn't seem to continue.
//See source:
//https://docs.mulesoft.com/mule-runtime/4.4/try-scope-concept#handling-transactions
In both cases, the flow in which the Try scope resides continues.

In the Anypoint Studio UI, transaction options look like this:

image::transaction-try-scope-config.png[Try Scope Configuration]

The following example shows a JMS Listener `<jms:listener />` operation that starts a transaction at the flow level, a Try scope that sets a `transactionalAction` value based on a custom xref:configuring-properties.adoc[configuration property] `${action}`, and a `<jms:publish />` operation configured to run outside of the transaction:

[source,xml,linenums]
----
<flow name="someFlow">
	<jms:listener config-ref="JMS_Config" destination="test.in" transactionalAction="ALWAYS_BEGIN"/>
	<!-- Processors -->
	<try transactionalAction="${action}">
		<!-- Processors -->
		<!-- Join if possible is the default value for jms:publish operation -->
		<jms:publish config-ref="JMS_Config" destination="test.out" transactionalAction="NOT_SUPPORTED"/>
		<raise-error type="APP:SOME"/>
		<!-- More Processors -->
	</try>
	<!-- Processors -->
</flow>
----

If operations within the Try scope execute without producing an error, the scope finishes the execution and commits the transaction, independently of its configured `transactionalAction` value.

When an error occurs within the Try scope, the success or failure of the transaction depends on the value of `transactionalAction` in the scope and in other operations in the flow. The example adds the `<raise-error/>` component within the Try scope to demonstrate an error case.

* Ignore (`INDIFFERENT`)
+
If the Try scope's `transactionalAction` is set to this value in the example, the transaction continues while executing the operations within the scope, unless that behavior is overridden within the scope.
//TODO: Re "propagates to the source" below,
//      WHERE DOES THE ERROR PROPAGATE TO? THE SCOPE OR THE FLOW OR WHERE?
When raised within the Try scope, the error propagates to the source by default, the transaction rolls back, and the message becomes available again in the JMS queue. This rollback does not affect the completed `<jms:publish />` operation, which is outside of the transaction scope because its `transactionAction` property is set to `NOT_SUPPORTED`.
+
To roll back the `<jms:publish />` operation as part of the transaction, it is necessary to use the default setting (`JOIN_IF_POSSIBLE`) or to configure the setting `transactionAction="ALWAYS_JOIN"`.
+
* Always Begin (`ALWAYS_BEGIN`)
+
//TODO: WHAT HAPPENS IN THIS CASE?
If the Try scope's `transactionalAction` is set to this value in the example, an error occurs because an active transaction started by `<jms:listener ... transactionalAction="ALWAYS_BEGIN"/>` already exists.
* Begin or Join (`BEGIN_OR_JOIN`)
+
If the Try scope's `transactionalAction` is set to this value in the example, the scope joins the active transaction started by `<jms:listener ... transactionalAction="ALWAYS_BEGIN"/>`. In this case, the result is the same as using `INDIFFERENT`.

For another example, see xref:transaction-management.adoc#configuring-a-transaction-in-a-try-scope[Configuring a Transaction in a Try Scope].

[[error_handling]]
== Handling Errors Within the Try Scope

As with the Flow component, you can configure the Try scope to handle errors differently based on the error type, such as `DB:CONNECTIVITY` or `DB:BAD_SQL_SYNTAX` database error types. The scope's embedded Error Handler component (`<error-handler />`) accepts the same components as the Flow component's error handler:

* On Error Continue (`<on-error-continue />`)
+
Executes, sends the result of its execution to Try scope, and commits any transactions. The Try scope uses the result to complete its execution successfully.
* On Error Propagate (`<on-error-propagate />`)
+
Executes, re-throws the error, and rolls back any transactions. Re-throwing the error causes the Try scope's execution to fail.

The following example shows a Try Scope configuration within Anypoint Studio:

image::error-handling-try-scope.png[Error Handling with the Try Scope]

The configuration XML for this basic example looks like this:

[source,XML]
----
<!-- Database Connector Configuration -->
<db:config name="Database_Config1" doc:name="Database Config" >
	<db:my-sql-connection host="localhost" port="3306"
	                      user="root" password="mysecretpw"
												database="my_db_example"/>
</db:config>
<!-- Flow -->
<flow name="try-scope-errorhandling-ex" >
	<scheduler doc:name="Scheduler" >
		<scheduling-strategy >
			<fixed-frequency frequency="15" timeUnit="SECONDS"/>
		</scheduling-strategy>
	</scheduler>
	<!-- Try Scope -->
	<try doc:name="Try" >
	  <!-- Database Select Operation -->
		<db:select doc:name="Select"
		           config-ref="Database_Config1">
			<db:sql ><![CDATA[SELECT title FROM movies;]]></db:sql>
		</db:select>
		<!-- Logger Inside Try Scope -->
		<logger level="INFO" doc:name="Logger"
		        message="#[%dw 2.0&#10;output application/json&#10;---&#10;payload]"/>
		<!-- File Write Operation -->
		<file:write doc:name="Write" path="/Users/me/testing/db/mydbdata">
			<file:content ><![CDATA[#[%dw 2.0
output application/csv
---
payload]]]></file:content>
		</file:write>
		<!-- Error Handler -->
		<error-handler >
		  <!-- On Error Propagate for DB:CONNECTIVITY errors -->
			<on-error-propagate enableNotifications="true" logException="true" doc:name="On Error Propagate" type="DB:CONNECTIVITY">
				<logger level="INFO" doc:name="Logger"
				        message="#[onErrorPropagate : error]"/>
			</on-error-propagate>
			<!-- On Error Continue for ANY other errors -->
			<on-error-continue enableNotifications="true" logException="true" doc:name="On Error Continue" type="ANY">
				<logger level="INFO" doc:name="Logger"
				        message="#[onErrorContinue : error.description]"/>
			</on-error-continue>
		</error-handler>
	</try>
	<!-- Logger After Try Scope -->
	<logger level="INFO" doc:name="Logger" message='"Example: Logger After Try"'/>
</flow>
----

In this example, a database connection error `DB:CONNECTIVITY` propagates because of the On Error Propagate (`<on-error-propagate />`) error handler. Propagation of this error causes the Try scope's (`<try />`) execution to fail and the scope's error handler to execute the Logger within the Try scope but not the Logger after the scope:

[source,logs]
----
INFO  ...LoggerMessageProcessor: {onErrorPropagate=DB:CONNECTIVITY}
----

On Error Continue (`on-error-continue`) accepts other errors that occur within the scope. The Logger within _and after_ the Try scope execute when these errors occur.

[source,logs]
----
INFO  ...LoggerMessageProcessor: {onErrorContinue=DB:BAD_SQL_SYNTAX}
INFO  ...LoggerMessageProcessor: "Example: Logger After Try"
----

After a component within the Try scope raises an exception, any subsequent components in the scope _do not_ execute, regardless of the type of error handler that catches the exception.

Each error handling strategy in a Try scope (`on-error-*`) follows a condition. This condition is typically an error type (or a list of several) which must match the current error. You can also define this condition as a DataWeave expression, such as `error.cause.message.contains("fatal")`.

[NOTE]
Conditions are evaluated in order, and only the first strategy to match is executed.

Below is an example that includes two error handling strategies, each executing a logger component:

[source,xml,linenums]
----
<try>
  <http:request config-ref="HTTP-config" method="GET" path="/" />
  <error-handler>
    <on-error-continue enableNotifications="true" logException="true" type="CONNECTIVITY">
      <logger level="INFO" doc:name="Logger" message="Connectivity Error"/>
    </on-error-continue>
    <on-error-propagate enableNotifications="true" logException="true" doc:name="On Error Propagate" type="EXPRESSION">
      <logger level="INFO" doc:name="Logger" message="Expression error" />
    </on-error-propagate>
  </error-handler>
</try>
----

=== Error Handler at Flow Level

In the following example, an error handler is added at flow level:

[source,xml,linenums]
----
<flow name="someFlow">
	<jms:listener config-ref="JMS_Config" destination="test.in" transactionalAction="ALWAYS_BEGIN"/>
	<!-- Processors -->
	<try transactionalAction="${action}">
		<!-- Processors -->
		<!-- Join if possible is the default value for jms:publish operation -->
		<jms:publish config-ref="JMS_Config" destination="test.out"/>
		<raise-error type="APP:SOME"/>
		<!-- More Processors -->
	</try>
	<!-- Processors -->
	<error-handler>
		<on-error-continue/>
	</error-handler>
</flow>
----

The behavior in this example is:

* Ignore (`INDIFFERENT`)
+
The transaction continues. Because the error is handled by an `on-error-continue` error handler, the transaction is committed. The message read from the `jms:listener` source is consumed, and the message processed by the `jms:publish` operation is actually sent.
* Always Begin (`ALWAYS_BEGIN`)
+
Raises an error because an active transaction already exists.
* Begin or Join (`BEGIN_OR_JOIN`)
+
Displays the same behavior as `INDIFFERENT`.

=== Error Handler Inside the Try Scope

In this case, the error handler is inside the Try scope and the error occurs after the execution of the scope:

[source,xml,linenums]
----
<flow name="someFlow">
	<jms:listener config-ref="JMS_Config" destination="test.in" transactionalAction="ALWAYS_BEGIN"/>
	<!-- Processors -->
	<try transactionalAction="${action}">
		<!-- Processors -->
		<!-- Join if possible is the default value for jms:publish operation -->
		<jms:publish config-ref="JMS_Config" destination="test.out"/>
		<!-- More Processors -->
		<!-- There could be a component that raises an error, it will be handled by the error handler -->
		<error-handler>
			<on-error-continue/>
		</error-handler>
	</try>
	<!-- Processors -->
	<raise-error type="APP:SOME"/>
</flow>
----

Depending on the configured `transactionalAction`, the behavior in the Try scope is one of the following:

* Ignore (`INDIFFERENT`)
+
The transaction continues but the error is not handled by an `on-error-continue` at the flow level, causing the transaction to be rolled back, and the message to not be sent.
* Always Begin (`ALWAYS_BEGIN`)
+
Raises an error because an active transaction already exists.
* Begin or Join (`BEGIN_OR_JOIN`)
+
Displays the same behavior as `INDIFFERENT`.



== Variable and Payload Propagation

Every payload modification or variable addition, modification, or removal is propagated through the rest of the execution. This propagation includes modifications that take place inside the error handlers.


[[reference]]
== Reference

The Try scope provides a set of configurable properties for transaction management and a custom display name.

[[properties]]
[%header,cols="1a,1a,1a,4a"]
|===
|Property | XML | Default |Description
| *Display Name* | `doc:name` | `"Try"` | Configurable name for a Try scope.
| *Transaction Action* | `transactionalAction` | `INDIFFERENT` | Indicates whether to treat processing within the scope as a transaction:

* `INDIFFERENT` (Default): Join an existing transaction, but do not start a new  transaction. Components and operations within the Try scope join the active transaction unless they override this setting.
* `ALWAYS_BEGIN`: Start a new transaction of the type specified by the Transactional Type (`transactionalType`) each time the scope executes.
//TODO: when WHAT is already running within ...?
`ALWAYS_BEGIN` is an _invalid_ configuration when already running within a single-resource transaction.
* `BEGIN_OR_JOIN`: Join the existing transaction within the flow or initiate a new transaction if there is no transaction yet. If a transaction already exists, ignore the Transactional Type (`transactionalType`) setting. This setting is relevant only when execution order might vary, for example, due to asynchronous actions occurring outside the flow.

| *Transaction Type* |`transactionalType` | `LOCAL` | Defines the type of transaction to use. The Try scope uses this configuration only when a new transaction is created. The type cannot change while a transaction executes.

* `LOCAL`
* `XA`

|===

== See Also

* xref:error-handling.adoc[Error Handling]
* xref:transaction-management.adoc[Transaction Management]
* xref:jms-connector::index.adoc[]
