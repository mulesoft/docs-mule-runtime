= Scatter-Gather Router
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

The Scatter-Gather component is a routing event processor. It copies (scatters) a Mule event to two or more parallel routes, each route being a sequence of one or more event processors that is similar to a subflow. Each route uses a separate thread and creates a Mule event, which has its own payload, attributes, and variables. The Scatter-Gather component then consolidates (gathers) the Mule events from each route together into a new Mule event and passes this consolidated Mule event to the next event processor. The Scatter-Gather component passes a consolidated Mule event to the next event processor only after every route completes successfully.

The Scatter-Gather component executes each route in parallel, not sequentially. Parallel execution of routes can greatly increase the efficiency of your Mule application and may provide more information than sequential processing.

image::scatter-gather-concept-56ccc.png[]

WARNING: A Scatter-Gather component cannot be configured with only one route. A Mule application will throw an exception and not start if it contains a flow in which a Scatter-Gather component has not been configured with at least two routes.

== How Errors Generated Inside Scatter-Gather Routes are Handled

You can use a Try scope in each route of a Scatter-Gather component to handle any errors that might be generated by a route’s event processors. Unhandled errors that are thrown because of a problem in a route cause the Scatter-Gather component to also throw an error of type `MULE:COMPOSITE_ERROR`. The component throws this error only after every route either completes or fails. Event processing does not proceed further than the Scatter-Gather component in the flow. Instead, the flow branches to your error-handling event processors. The `MULE:COMPOSITE_ERROR` error object gathers together not only the errors from the route that failed, but also the Mule events from completed routes, so that your application can still process Mule events from the routes that completed by using your error-handling event processors.

To illustrate how this works, let’s look at two cases. In the first case, the routes in a Scatter-Gather component each contain a Try scope. One of the routes generates an error that is successfully handled by that route’s Try scope, so the route is still able to generate a Mule event. The Scatter-Gather component consolidates the Mule events from all routes into a new Mule event, as usual, and passes the consolidated event to the next event processor.

In the second case, an error occurs in a route. This route either does not contain a Try scope or the error is of a type that the Try scope cannot handle. Although the other routes all complete, the one failed route causes the Scatter-Gather component to throw a `MULE.COMPOSITE ERROR` error, which the flow passes to the Error Handler component that you have configured for your flow. The error-handling event processors are able to process the Mule events from the completed routes.

Example of handling these errors:
[source,xml,linenums]
----
<flow name="errorHandler">
    <scatter-gather>
        <route>
            <raise-error type="APP:MYERROR"/>
        </route>
        <route>
            <set-payload value="apple"/>
        </route>
    </scatter-gather>
    <error-handler>
        <on-error-continue type="COMPOSITE_ROUTING">
            <!-- This will have the error thrown by the first route -->
            <logger level="WARN" message="#[error.errorMessage.payload.failures['0']]"/>
            <!-- This will be a null value -->
            <logger level="WARN" message="#[error.errorMessage.payload.failures['1']]"/>

            <!-- This will be a null value -->
            <logger level="WARN" message="#[error.errorMessage.payload.results['0']]"/>
            <!-- This will have the result of the second (correctly executed) route -->
            <logger level="WARN" message="#[error.errorMessage.payload.results['1']]"/>
        </on-error-continue>
    </error-handler>
</flow>
----

== Variable Propagation

Every route starts with the same initial variable values. Modifications to a variable within a specific route do not affect other routes. So, if a variable is added or modified in one route, then, after aggregation, the value is defined by that route. If a variable is added or modified by more than one route, the value is added to a list of all the values defined for that variable within all the routes, for example:

[source,xml,linenums]
----
<set-variable variableName="var1" value="var1"/>
<set-variable variableName="var2" value="var2"/>
<scatter-gather doc:name="Scatter-Gather" doc:id="abc665e0-6119-4ecb-9f8b-52dbcbb1d488" >
	<route >
		<set-variable variableName="var2" value="newValue"/>
        <set-variable variableName="var3" value="appleVal"/>
	</route>
	<route >
		<set-variable variableName="var3" value="bananaVal"/>
	</route>
	<route >
		<set-variable variableName="var3" value="otherVal"/>
        <set-variable variableName="var4" value="val4"/>
	</route>
</scatter-gather>
----

After aggregation, the variables are:

`{var1: "var1", var2: "newValue", var3: ["appleVal, bananaVal, otherVal"], var4: "val4"}`

## How Scatter-Gather Timeout Errors are Handled

You can configure a timeout for a Scatter-Gather component. If a route does not complete processing before the period of time set in the timeout expires, the route throws a MULE:TIMEOUT error. This error is then handled the same way as any other error generated from a route: after each route completes (either by completing its last event processor or by throwing a MULE:TIMEOUT error), the successful results and errors are collected together and thrown by the Scatter-Gather component as a MULE:COMPOSITE error, which can then be processed in an error handler.

## Example
In Anypoint Studio, you can download and open the example project _Scatter-Gather Flow Control_ from Anypoint Exchange to learn more about how to use the Scatter-Gather component. This example shows the usage of the scatter-gather control flow to aggregate data in parallel and return the result in JSON.

The example uses prepared data as input for two resources that should be aggregated. The data represents information about two contacts and has the following structure:

|===
Resource|`firstname`|`surname`|`phone`|`email`
|contacts-1.csv
|John
|Doe
|096548763
|john.doe@texasComp.com

|contacts-2.csv
|Jane
|Doe
|091558780
|jane.doe@texasComp.com
|===

DataWeave is used to aggregate the data. The information about the contacts is aggregated to a JSON structure that represents data from both resources.

To download and open this example project while you are in Anypoint Studio, click the Exchange icon in the upper-left corner. Then, in the window that opens, log into Anypoint Exchange and search on the name of the project.

==== Throws

* `MULE:ROUTING`
* `MULE:COMPOSITE_ROUTING`

== See Also

* xref:scatter-gather-xml-reference.adoc[Scatter-Gather XML Reference]
* xref:about-components.adoc[Core Components]
* xref:transaction-management.adoc#tx_scopes_routers[How Transactions Affect Scopes and Routers]
