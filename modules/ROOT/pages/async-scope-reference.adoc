= Async Scope
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: Async, scopes, studio, anypoint

The Async scope provides a mechanism for processing the xref:about-mule-event.adoc[Mule event] simultaneously with the main flow. The flow does not wait for the last processor within the asynchronous flow to complete its tasks, and Async does not block the execution of downstream components outside of Async.

Async is useful for executing time-consuming operations that do not require a response to the initiating flow, for example, when printing a file or connecting to an email server.

image::async-scope-schematic.png[Async+scope+schematic]

Because the Async scope executes in a "fire and forget" manner, the result of  processing within the scope is not available in the main flow except in the case of <<mutable_objects, mutable objects>> that are modified within Async.

The Async scope does not inherit the exception strategy of the main flow. To handle errors in an Async scope, use the xref:try-scope-concept.adoc[Try scope].

////
// TODO: Recommend removing the following bullets:
//TODO: Next bullet belongs (and is) in the main description.
* Processes messages asynchronously.
  //TODO: This is not always true apparently. See info on mutable objects:
* Does not pass data back to the main flow.
//TODO: Recommend removing the following bullets,
//      as the distinction from subflow isn't necessary:
* Exists inline with the main flow thread.
* Is not called by a Flow Reference component.
* Is not reusable
////

[[mutable_objects]]
== Async Scope Behavior with Mutable Objects

To facilitate simultaneous branch processing, the Async scope sends one copy of the Mule event (the Mule message and any Mule variables) it receives to the first processor within its processing block. At the same time, the scope sends another copy of this event to the next processor in the main flow.

Though the Async scope receives a copy of the Mule message, Mule does not copy the payload. Instead, each Mule message references the same payload. One payload continues in the main flow, and the other is processed within the Async scope.

If the payload of your message is a mutable object (for example, a bean with different fields in it) and a message processor in your Async scope changes the value of one of the fields, the message processors outside of the Async scope see the changed values.

//TODO: Ivan, feel free to ADD ANY RECOMMENDATION HERE

== Example Async Scope Configuration

The following XML fragment shows an example configuration of an Async scope inside an application flow. The Async scope contains a `file:read` operation that executes asynchronously once triggered, while the application continues processing the next operation in the flow, `http:request`:

[source,xml,linenums]
----
<!-- Main application flow -->
<flow name="myMainFlow" >
  <!-- HTTP Listener as event source -->
  <http:listener doc:name="Listener" />
  <!-- A Transform operation that executes as part of the main flow -->
  <ee:transform doc:name="Transform Message" >
    <ee:message >
      <ee:set-payload >
        <![CDATA[%dw 2.0
        output application/json
        ---
        payload]]>
      </ee:set-payload>
    </ee:message>
  </ee:transform>
    <!-- The Async scope executes its message processors in a different thread, while the main flow continues its execution -->
    <async doc:name="Async" >
      <!-- A Try scope to handle errors, because the async scope does not inherit the error strategy from the flow -->
      <try doc:name="Try" >
        <!-- A Write operation -->
        <file:write doc:name="Write" path="/" />
        <!-- Error handling strategy defined in the Try scope, to handle errors during the Async scope execution -->
        <error-handler >
          <on-error-continue enableNotifications="true" logException="true" doc:name="On Error Continue" type="ANY">
            <!-- Some error handling logic for this strategy -->
            ...
          </on-error-continue>
        </error-handler>
      </try>
    </async>
  <!-- This HTTP Request operation starts executing without waiting for the Async scope to finish its execution -->
  <http:request method="GET" doc:name="Request" />
  ...
</flow>
----

== Reference

Async scopes are configurable.

[%header,cols="1a,1a,1a,4a"]
|===
| Field | XML | Default | Description
| *Display Name* | `name` | Async | Name for the Async scope.
| *Max Concurrency* | `maxConcurrency` | See description. |  Optional.
//TODO: Re "maximum number of _messages_" next, is it limited to Mule messages?
//      What is processed concurrently?
Sets the maximum number of concurrent messages that the scope can process. By default, the container thread pool optimizes performance by determining the maximum number of threads to use.

Setting `maxConcurrency` to `1` causes the scope to process requests one at a time and not in parallel.

Upon reaching maximum concurrency, the scope cannot receive additional requests. See xref:execution-engine.adoc#backpressure[Back-Pressure Management] for details about the behavior of Mule when it reaches the maximum concurrency value.
|===


== See Also

* xref:about-mule-event.adoc[]
* xref:about-components.adoc[]
* xref:transaction-management.adoc#tx_scopes_routers[How Transactions Affect Scopes and Routers]
* xref:tuning-backpressure-maxconcurrency.adoc[]
