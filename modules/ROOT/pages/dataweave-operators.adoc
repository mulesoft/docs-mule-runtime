= DataWeave Operators
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: studio, anypoint, esb, transform, transformer, format, aggregate, rename, split, filter convert, xml, json, csv, pojo, java object, metadata, dataweave, data weave, datamapper, dwl, dfl, dw, output structure, input structure, map, mapping

In xref:dataweave.adoc[DataWeave] you can carry out many different operations on the elements of a DataWeave transform. 

In DataWeave, most operators are actually implemented as two argument functions, such as combining the map and filter operators ```filter(map([1,10,30,50], $*10, $ < 200)```, but this is usually cleaner and easier to read when you write these functions out as chained operations, such as ```[1,10,30,50] map $*10 filter $ < 200```. 

This document serves as a reference for all of the available operators in the DataWeave language. See xref:dataweave-types.adoc#dataweave-operators-sorted-by-type[all operators sorted by type]

* For an introduction to the essentials of the language, see xref:dataweave-language-introduction.adoc[DataWeave Language Intro]
* For information on DataWeave's accepted types, see xref:dataweave-types.adoc[DataWeave Types]
* For an index of all available operators, categorized by the types you need to supply as parameters, see xref:dataweave-types.adoc#operators-sorted-by-type[DataWeave Operators Sorted by Type].
* See xref:dataweave-types.adoc#functions-and-lambdas[Functions and Lambdas] to learn how to create your own DataWeave functions.

[TIP]
Check the xref:dataweave-language-introduction.adoc#precedence-table[Precedence Table] to see the order in which DataWeave expressions are compiled.


=== Using Mapping Operators to Loop Over Collections
DataWeave does not have any explicit looping operators like `for` in Java and C. Instead, there are a family of mapping operators that allow you to loop over various collections. 
 
* The `map` operator iterates over each element of an Array type input and applies a lambda transformation to each individual element, then combines each transformed element together into the resulting array. 

* The `mapObject` operator iterates over each element of an Object type input and applies a lambda transformation to each individual entry (key/value pair), then combines each transformed entry together into the resulting object.  

* The `pluck` operator iterates over each entry (key/value) of an Object type input and applies a lambda transformation to each individual entry (key/value pair), then combines each transformed entry together into a resulting array. 

* The `reduce` operator begins with an accumulator of any DataWeave type, then iterates over each element of an Array type input and applies a lambda transformation to each element of the array. Typically the reduce operator incorporates the accumulator into the per-element lambda transformation, allowing each element's value to be combined together into the final accumulated value. Unlike the other three mapping operators, the reduce operator is able to produce any type of output depending on the type of the initial accumulator and how the accululator is updated by the lambda expression. The reduce operator is the most complicated, but also the most flexible, of all the mapping operators, and in fact every other operator can be built from the reduce operator. 

== The Map Operator



=== Using Map to Return an Array

.(':array', ':function')  => :array

Returns an array that is the result of applying a transformation function (lambda) to each of the elements.
The lambda is invoked with two parameters: *index* and the *value*.
If these parameters are not named, the index is defined by default as *$$* and the value as *$*.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
users: ["john", "peter", "matt"] map  upper $
----

.Output
[source,json,linenums]
----
{
  "users": [
  "JOHN",
  "PETER",
  "MATT"
  ]
}
----

In the following example, custom names are defined for the index and value parameters of the map operation, and then both are used to construct the returned value.
In this case, value is defined as *firstName* and its index in the array is defined as *position*.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
users: ["john", "peter", "matt"] map ((firstName, position) -> position ++ ":" ++ upper firstName)
----

.Output
[source,json,linenums]
----
{
  "users": [
    "0:JOHN",
    "1:PETER",
    "2:MATT"
  ]
}
----


=== Using Map on an Object

.(':object', ':function')  => ':array'

Returns an array with the values that result out of applying a transformation function (lambda) to each of the values in the object. The keys of the original object are all ignored by this operation and the object is treated as an array. To have access to the keys, you can use the operation *mapObject* instead.
The lambda is invoked with two parameters: *index* and the *value*.
If these parameters are not named, the index is defined by default as *$$* and the value as *$*. The index refers to the position of a key:value pair when the object is treated as an array.

[TIP]
See <<map-object,Map Object>> if what you want is to process both keys and values instead of just values.


.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
%var conversionRate=13.45
---
priceList: payload.prices map (
  '$$':{
    dollars: $,
    localCurrency: $ * conversionRate
  }
)
----


[.ex]
=====
[discrete.view]
=== Input: XML

.Input
[source,xml,linenums]
----
<prices>
    <basic>9.99</basic>
    <premium>53</premium>
    <vip>398.99</vip>
</prices>
----

[discrete.view]
=== Output: JSON

.Output
[source,json,linenums]
----
{
  "priceList": [
    {
      "0": {
        "dollars": "9.99",
        "localCurrency": 134.3655
      }
    },
    {
      "1": {
        "dollars": "53",
        "localCurrency": 712.85
      }
    },
    {
      "2": {
        "dollars": "398.99",
        "localCurrency": 5366.4155
      }
    }
  ]
}
----

=====







[TIP]
Note that when you use a parameter to populate one of the keys of your output, as with the case of $$ in this example, you must either enclose it in quote marks or brackets. '$$' or ($$) are both equally valid.

In the example above, as key and value are not defined, they're identified by the placeholders *$$* and *$*.
For each key:value pair in the input, an object is created and placed in an array of objects. Each of these objects contains two properties:
one of these directly uses the value, the other multiplies this value by a constant that is defined as a directive in the header.

The mapping below performs exactly the same transform, but it defines custom names for the properties of the operation, instead of using $ and $$. Here, `position` is defined as referring to the array index, and `money` to the value in that index.  The reference to the array index (named `position`, in this case) is optional.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
%var conversionRate=13.45
---
priceList: payload.prices map ((money, position) ->
  '$position':{
    dollars: money,
    localCurrency: money * conversionRate
  }
)
----

The reference to the array index is optional. This is also a valid example:

 .Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
%var conversionRate=13.45
---
priceList: payload.prices map ((money) ->
  {
    dollars: money,
    localCurrency: money * conversionRate
  }
)
----

[TIP]
Note that when you use a parameter to populate one of the keys of your output, as with the case of `position` in this example, you must either enclose it in brackets or enclose it in quote marks adding a $ to it, otherwise the name of the property is taken as a literal string. '$position' or (position) are both equally valid.

[[map-object]]
== Map Object

.(':object', ':function')  => ':object'

Similar to Map, but instead of processing only the values of an object, it processes both keys and values as a tuple. Also instead of returning an array with the results of processing these values through the lambda, it returns an object, which consists of a list of the key:value pairs that result from processing both key and value of the object through the lambda.

The lambda is invoked with two parameters: *key* and the *value*.
If these parameters are not named, the key is defined by default as *$$* and the value as *$*.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
%var conversionRate=13.45
---
priceList: payload.prices mapObject (
  '$$':{
    dollars: $,
    localCurrency: $ * conversionRate
  }
)
----


[.ex]
=====
[discrete.view]
=== Input: XML

.Input
[source,xml,linenums]
----
<prices>
    <basic>9.99</basic>
    <premium>53</premium>
    <vip>398.99</vip>
</prices>
----

[discrete.view]
=== Output: JSON

.Output
[source,json,linenums]
----
{
  "priceList": {
    "basic": {
      "dollars": "9.99",
      "localCurrency": 134.3655
    },
    "premium": {
      "dollars": "53",
      "localCurrency": 712.85
    },
    "vip": {
      "dollars": "398.99",
      "localCurrency": 5366.4155
    }
  }
}
----

=====



[TIP]
Note that when you use a parameter to populate one of the keys of your output, as with the case of $$ in this example, you must either enclose it in quote marks or brackets. '$$' or ($$) are both equally valid.

In the example above, as key and value are not defined, they're identified by the placeholders *$$* and *$*.
For each key:value pair in the input, the key is preserved and the value becomes an object with two properties:
one of these is the original value, the other is the result of multiplying this value by a constant that is defined as a directive in the header.

The mapping below performs exactly the same transform, but it defines custom names for the properties of the operation, instead of using $ and $$. Here, 'category' is defined as referring to the original key in the object, and 'money' to the value in that key.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
%var conversionRate=13.45
---
priceList: payload.prices mapObject ((money, category) ->
  '$category':{
    dollars: money,
    localCurrency: money * conversionRate
  }
)
----

[TIP]
Note that when you use a parameter to populate one of the keys of your output, as with the case of *category* in this example, you must either enclose it in brackets or enclose it in quote marks adding a $ to it, otherwise the name of the property is taken as a literal string. '$category' or (category) are both equally valid.

== Pluck

.(':object', ':function')  => ':array'

Pluck is useful for mapping an object into an array. Pluck is an alternate mapping mechanism to mapObject.
Like mapObject, pluck executes a lambda over every key:value pair in its processed object as a tuple,
but instead of returning an object, it returns an array, which may be built from either the values or the keys in the object.

The lambda is invoked with two parameters: *key* and the *value*.
If these parameters are not named, the key is defined by default as *$$* and the value as *$*.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
result: {
  keys: payload.prices pluck $$,
  values: payload.prices pluck $
}
----


[.ex]
=====
[discrete.view]
=== Input: XML

.Input
[source,xml,linenums]
----
<prices>
    <basic>9.99</basic>
    <premium>53</premium>
    <vip>398.99</vip>
</prices>
----

[discrete.view]
=== Output: JSON

.Output
[source,json,linenums]
----
{
  "result": {
    "keys": [
      "basic",
      "premium",
      "vip"
    ],
    "values": [
      "9.99",
      "53",
      "398.99"
    ]
  }
}
----
=====








== Filter

=== Using Filter on an Array

.(':array', ':function') => ':array'

Returns an array that only contains those that pass the criteria specified in the lambda. The lambda is invoked with two parameters: *index* and the *value*.
If these parameters are not named, the index is defined by default as *$$* and the value as *$*.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  biggerThanTwo: [0, 1, 2, 3, 4, 5] filter $ > 2
}
----

.Output
[source,json,linenums]
----
{
  "biggerThanTwo": [3,4,5]
}
----


=== Using Filter on an Object

.(':object', ':function')  => ':object'

Returns an object with the key:value pairs that pass the acceptance criteria defined in the lambda.
If these parameters are not named, the index is defined by default as *$$* and the value as *$*.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/xml
---
filtered: {
  aa: "a", bb: "b", cc: "c", dd: "d"
} filter $ == "d" <1>
----
<1> Filters the all key:value pairs with value "d" => {dd:d}

.Output
[source,xml,linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<filtered>
  <dd>d</dd>
</filtered>
----

[TIP]
====
If you require to filter by key, you need to use <<map-object,mapObject>> and *when*. For example, to filter the last example by key:
[source,raml,linenums]
----
%dw 1.0
%output application/xml
---
filtered: {
  aa: "a", bb: "b", cc: "c", dd: "d"
} mapObject ({ ($$): $ } when $$ as :string == "dd" otherwise {})
----
====

== Remove

=== Using Remove on an Array
.(':array', ':name')  => ':array'

When running it on an array, it returns another array where the specified indexes are removed.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  aa: ["a", "b", "c"] - 1
}
----

.Output
[source,json,linenums]
----
{
  "aa": [a, c]
}
----


=== Using Remove on an Object
.(':object', ':name')  => ':object'

When running it on an object, it returns another object where the specified keys are removed.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
myObject: {aa: "a", bb: "b"} - "aa"
----

.Output
[source,json,linenums]
----
{
  "myObject": {
    "bb": "b"
  }
}
----

The above example removes the key value pair that contains the key 'aa' from {aa: "a", bb: "b"} => {bb: "b"}


== Remove by Matching Key and Value
.(':object', ':object')  => ':object'

Works just like <<using remove on an object, remove>> on objects, but only removes an element when there is a match of not just the key but of the key + value pair . It returns another object where the specified keys are removed.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
myObject: {aa: "a", aa:"c", bb: "b"} -- { aa:"a"}
----

.Output
[source,json,linenums]
----
{
  "myObject": {
    "aa": "c",
    "bb": "b"
  }
}
----

The above example removes the key value pair that contains both the key 'aa' and value "a", but not the one that contains only a matching key but not value.


== AND

The expression *and* (in lower case) can be used to link multiple conditions, its use means that all of the linked conditions must evaluate to true for the expression as a whole to evaluate to true.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  currency: "USD"
} when payload.country == "USA" and payload.currency == "local"
otherwise
{
      currency: "EUR"
}
----

In the example above, currency is "EUR", unless the payload has BOTH conditions met.

[TIP]
Check the xref:dataweave-language-introduction.adoc#precedence-table[Precedence Table] to see what expressions are compiled before or after this one.

== OR

The expression *or* (in lowercase) can be used to link multiple conditions. Its use means that either one or all of the linked conditions must evaluate to true for the expression as a whole to evaluate to true. This example combines the usage of *OR* with the xref:dataweave-language-introduction.adoc#when-otherwise[when and otherwise] expressions.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  currency: "EUR"
} when payload.country == "Italy" or payload.country == "Germany" or payload.country == "Spain" or payload.country == "Portugal" or payload.country == "France" or payload.country == "Greece"
otherwise
{
      currency: "USD"
}
----

In the example above, currency is "EUR", only when one of the conditions evaluates to true.

[TIP]
Check the xref:dataweave-language-introduction.adoc#precedence-table[Precedence Table] to see what expressions are compiled before or after this one.

== IS
.(':any', condition)  => ':boolean'

Evaluates if a condition validates to true and returns a boolean value. Conditions may include `and` and `or` operators.


.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/xml
---
ROOT: payload.root.*order mapObject (
  ORDER:{
    itemsCollectionPresent: $ is :object and $.items?
  }
)
----


[.ex]
=====
[discrete.view]
=== Input: XML

.Input
[source,xml,linenums]
----
<root>
    <order>
      <items> 155 </items>
    </order>
    <order>
      <items> 30 </items>
    </order>
    <order>
        null
    </order>
</root>
----

[discrete.view]
=== Output: XML

.Output
[source,xml,linenums]
----
<?xml version='1.0' encoding='UTF-8'?>
<ROOT>
  <ORDER>
    <itemsCollectionPresent>true</itemsCollectionPresent>
  </ORDER>
  <ORDER>
    <itemsCollectionPresent>true</itemsCollectionPresent>
  </ORDER>
  <ORDER>
    <itemsCollectionPresent>false</itemsCollectionPresent>
  </ORDER>
</ROOT>
----
=====









== Concat

The concat operator is defined using double plus signs. You must have spaces on both sides of them.


=== Using Concat on an Array

.(':array', ':array') => ':array'


When using arrays, it returns the resulting array of concatenating two existing arrays.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: [0, 1, 2] ++ [3, 4, 5]
}
----

.Output
[source,json,linenums]
----
{
  "a": [0, 1, 2, 3, 4, 5]
}
----

=== Using Concat on a String

.(':string', ':string') => ':string'

Strings are treated as arrays of characters, so the operation works just the same with strings.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  name: "Mule" ++ "Soft"
}
----

.Output
[source,json,linenums]
----
{
  "name": MuleSoft
}
----

=== Using Concat on an Object

.(':object', ':object') => ':object'

Returns the resulting object of concatenating two existing objects.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/xml
---
concat: {aa: "a"} ++ {cc: "c"}
----

.Output
[source,xml,linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<concat>
  <aa>a</aa>
  <cc>c</cc>
</concat>
----

The example above concatenates object {aa: a} and {cc: c} in a single one => {aa: a , cc: c}

== Contains

Evaluates if an array or list contains in at least one of its indexes a value that validates to true and returns a boolean value. You can search for a literal value, or match a regex too.

=== Using Contains on an Array
.(':array', ':any') => ':boolean'

You can evaluate if any value in an array matches a given condition:

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
ContainsRequestedItem: payload.root.*order.*items contains "3"
----


[.ex]
=====
[discrete.view]
=== Input: XML

.Input
[source,xml,linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<root>
    <order>
      <items>155</items>
    </order>
    <order>
      <items>30</items>
    </order>
    <order>
      <items>15</items>
    </order>
    <order>
      <items>5</items>
    </order>
    <order>
      <items>4</items>
      <items>7</items>
    </order>
    <order>
      <items>1</items>
      <items>3</items>
    </order>
    <order>
        null
    </order>
</root>
----

[discrete.view]
=== Output: JSON

.Output
[source,json,linenums]
----
{
  "ContainsRequestedItem": true
}
----
=====








=== Using Contains on a String

.(':string', ':string') => ':boolean'
.(':string', ':regex') => ':boolean'

You can also use contains to evaluate a substring from a larger string:

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
ContainsString: payload.root.mystring contains "me"
----


[.ex]
=====
[discrete.view]
=== Input: XML

.Input
[source,xml,linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<root>
  <mystring>some string</mystring>
</root>
----

[discrete.view]
=== Output: JSON

.Output
[source,json,linenums]
----
{
  "ContainsString": true
}
----
=====




Instead of searching for a literal substring, you can also match it against a regular expression:


.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
ContainsString: payload.root.mystring contains /s[t|p]ring/`
----


[.ex]
=====
[discrete.view]
=== Input: XML

.Input
[source,xml,linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<root>
  <mystring>A very long string</mystring>
</root>
----

[discrete.view]
=== Output: JSON

.Output
[source,json,linenums]
----
{
  "ContainsString": true
}
----
=====


== Type Coercion using `as`

Coerce the given value to the specified type.

[TIP]
DataWeave by default attempts to convert the type of a value before failing, so using this operator to convert is sometimes not required but still recommended.

[NOTE]
Check the xref:dataweave-types.adoc#type-coercion-table[type coercion table] to see what conversions between what types are allowed in DataWeave.

=== Coerce to string
.(':any', ':type') => ':string'

Any simple types can be coerced to string. If formatting is required (such as for a number or date) the format schema property can be used.

Date and number format schemas are based on Java https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[DateTimeFormatter] and https://docs.oracle.com/javase/8/docs/api/java/text/DecimalFormat.html[DecimalFormat].

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: 1 as :string {format: "##,#"},
  b: now as :string {format: "yyyy-MM-dd"},
  c: true as :string
}
----

.Output
[source,json,linenums]
----
{
  "a": "1",
  "b": "2015-07-07",
  "c": "true"
}
----

=== Coerce to number
.(':string', ':type') => ':number'

A string can be coerced to number. If the given number has a specific format the schema property can be used.

Any format pattern accepted by https://docs.oracle.com/javase/8/docs/api/java/text/DecimalFormat.html[DecimalFormat] is allowed.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: "1" as :number
}
----

.Output
[source,json,linenums]
----
%dw 1.0
%output application/json
---
{
  "a": 1
}
----

==== Coerce a date to number
.(':time', ':type') => ':number'

When coercing a date to a number, there is an extra parameter you can add – 'unit' – to specify what unit of time to use,

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  mydate1: |2005-06-02T15:10:16Z| as :number {unit: "seconds"},
  mydate2: |2005-06-02T15:10:16Z| as :number {unit: "milliseconds"}
}
----

.Output
[source,json,linenums]
----
{
  "mydate1": 1117725016,
  "mydate2": 1117725016000
}
----

[NOTE]
Only the values 'seconds' and 'milliseconds' are valid for using in the 'unit' parameter.

=== Coerce to date
.(':string', ':type')/(':number', ':type') => ':date'

Date types can be coerced from string or number.

Any format pattern accepted by https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[DateTimeFormatter] is allowed.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
 a: 1436287232 as :datetime,
 b: "2015-10-07 16:40:32.000" as :localdatetime {format: "yyyy-MM-dd HH:mm:ss.SSS"}
}
----

.Output
[source,json,linenums]
----
{
  "a": "2015-07-07T16:40:32Z",
  "b": "2015-10-07 16:40:32.000"
}
----

Through this operator you can also take a value that's already structured as a date, and transform it into a differently formatted date, for example:

.Transform
[source,dataweave,linenums]
----
%output application/json
---
{
    myDate: ((payload as :string) as :date {format: "yyyyMMdd"}) as :string {format: "MM-dd-yyyy"}
}
----

=== Coerce to Object
.(':any', ':type') => ':object'

You can coerce your input into a custom object type of whatever class you want.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  payload as :object {class : "soa.sfabs.SOAResponseInfoType\$ServiceInfo"}
}
----

[NOTE]
Keep in mind that if the class name contains any '$' characters, they must be escaped with a backslash (\).


== Type Of
.(':any') => ':type'

Returns the type of a provided element (eg: '":string"' , '":number"' )


.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
isString: typeOf payload.mystring
----


[.ex]
=====
[discrete.view]
=== Input: JSON

.Input
[source,json,linenums]
----
{
  "mystring":"a string"
}
----

[discrete.view]
=== Output: JSON

.Output
[source,json,linenums]
----
{
  "isString": ":string"
}
----
=====


== Flatten
.(':array') => ':array'

If you have an array of arrays, this function can flatten it into a single simple array.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
flatten payload
----


[.ex]
=====
[discrete.view]
=== Input: JSON

.Input
[source,json,linenums]
----
[
   [3,5],
   [9,5],
   [154,0.3]
]
----

[discrete.view]
=== Output: JSON

.Output
[source,json,linenums]
----
[
  3,
  5,
  9,
  5,
  154,
  0.3
]
----
=====



== Size Of
.(':array')/(':string')/(':object') => ':number'

Returns the number of elements in an array (or anything that can be converted to an array such as a string).

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  arraySize: sizeOf [1,2,3],
  textSize: sizeOf "MuleSoft",
  objectSize: sizeOf {a:1,b:2}
}
----

.Output
[source,json,linenums]
----
{
  "arraySize": 3,
  "textSize": 8,
  "objectSize": 2
}
----

== Array Push
.(:array', ':any') => ':array'

Pushes a new element to the end of an array.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
aa: [0, 1, 2] + 5
----

.Output
[source,json,linenums]
----
{
  "aa": [0, 1, 2, 5]
}
----

== Remove from Array
.(':array', ':any') => ':array'

Removes an element from an array when it matches the specified value. If multiple elements in the array match the value, they will all be removed.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: [0, 1, 1, 2] - 1,
  b: [{a: "a"}] - {a: "a"}
}
----

.Output
[source,json,linenums]
----
{
  "a": [0,2],
  "b": []
}
----

== Remove Matching from Array
.(':array', ':array') => ':array'

Removes a set of elements from an array when an element in the base array matches one of the values in the substracted array. If multiple elements in the array match a value, they will all be removed.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
a: [0, 1, 1, 2] -- [1,2]
----

.Output
[source,json,linenums]
----
{
  "a": [0],
}
----


== Average of Array
.(':array') => ':number'

Creates an average of all the values in an array and outputs a single number. The array must of course contain only numerical value in it.


.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: avg [1..1000],
  b: avg [1, 2, 3]
}
----

.Output
[source,json,linenums]
----
{
  "a": 500.5,
  "b": 2.0
}
----



== Reduce

.(':array', ':function') => ':any'

Apply a reduction to the array using just two parameters:
the accumulator (*$$*), and the value (*$*).
By default, the accumulator starts at the first value of the array.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
sum: [0, 1, 2, 3, 4, 5] reduce($$ + $)
----

.Output
[source,json,linenums]
----
{
  "sum": 15
}
----

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
concat: ["a", "b", "c", "d"] reduce($$ ++ $)
----

.Output
[source,json,linenums]
----
{
  "concat": "abcd"
}
----

In some cases, you may not want to use the first element of the array as an accumulator. To set the accumulator to something else, you must define this in a lambda.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
concat: ["a", "b", "c", "d"] reduce ((val, acc = "z") -> acc ++ val)
----

.Output
[source,json,linenums]
----
{
  "concat": "zabcd"
}
----


== Join By

.(':array', ':string') => ':string'

Merges an array into a single string value, using the provided string as a separator between elements.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
aa: ["a","b","c"] joinBy "-"
----

.Output
[source,json,linenums]
----
{
  "aa": "a-b-c"
}
----

== Split By

.(':string', ':string')/(':string', ':regex') => ':array'

Performs the opposite operation as Join By. It splits a string into an array of separate elements, looking for instances of the provided string and using it as a separator.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
split: "a-b-c" splitBy "-"
----

.Output
[source,json,linenums]
----
{
  "split": ["a","b","c"]
}
----

== Order By

.(':array', ':function')/(':object', ':function') => ':array'/':object'

Returns the provided array (or object) ordered according to the value returned by the lambda. The lambda is invoked with two parameters: *index* and the *value*.
If these parameters are not named, the index is defined by default as *$$* and the value as *$*.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
orderByLetter: [{ letter: "d" }, { letter: "e" }, { letter: "c" }, { letter: "a" }, { letter: "b" }] orderBy $.letter
----

.Output
[source,json,linenums]
----
{
  "orderByLetter": [
    {
      "letter": "a"
    },
    {
      "letter": "b"
    },
    {
      "letter": "c"
    },
    {
      "letter": "d"
    },
    {
      "letter": "e"
    }
  ]
}
----

[TIP]
====
The *orderBy* function doesn't have an option to order in descending order instead of ascending. What you can do in these cases is simply invert the order of the resulting array.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
orderDescending: ([3,8,1] orderBy $)[-1 to 0]
----

.Output
[source,json,linenums]
----
{ "orderDescending": [8,3,1] }
----

====


== Group By

.(':array', ':function') => ':object'

Partitions an array into a Object that contains Arrays, according to the discriminator lambda you define.
The lambda is invoked with two parameters: *index* and the *value*.
If these parameters are not named, the index is defined by default as *$$* and the value as *$*.


.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
"language": payload.langs groupBy $.language
----


[.ex]
=====
[discrete.view]
=== Input: JSON

.Input
[source,json,linenums]
----
{
  "langs": [
    {
      "name": "Foo",
      "language": "Java"
    },
    {
      "name": "Bar",
      "language": "Scala"
    },
    {
      "name": "FooBar",
      "language": "Java"
    }
  ]
}
----

[discrete.view]
=== Output: JSON

.Output
[source,json,linenums]
----
{
  "language": {
    "Scala": [
        {"name":"Bar", "language":"Scala"}
      ],
    "Java": [
        {"name":"Foo", "language":"Java"},
        {"name":"FooBar", "language":"Java"}
      ]
  }
}
----
=====



== Distinct By

.(':array', ':function') => ':array'

Returns only unique values from an array that may have duplicates.
The lambda is invoked with two parameters: *index* and *value*.
If these parameters are not defined, the index is defined by default as $$ and the value as $.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{

  	book : {
      title : payload.title,
      year: payload.year,
      authors: payload.author distinctBy $
    }
}
----


[.ex]
=====
[discrete.view]
=== Input: JSON

.Input
[source,json,linenums]
----
{
  "title": "XQuery Kick Start",
  "author": [
    "James McGovern",
    "Per Bothner",
    "Kurt Cagle",
    "James Linn",
    "Kurt Cagle",
    "Kurt Cagle",
    "Kurt Cagle",
    "Vaidyanathan Nagarajan"
  ],
  "year":"2000"
}
----

[discrete.view]
=== Output: JSON

.Output
[source,json,linenums]
----
{
  "book": {
    "title": "XQuery Kick Start",
    "year": "2000",
    "authors": [
      "James McGovern",
      "Per Bothner",
      "Kurt Cagle",
      "James Linn",
      "Vaidyanathan Nagarajan"
    ]
  }
}
----
=====



== Zip Arrays

.(':array', ':array') => ':array'

Given two or more separate lists, the zip function can be used to merge them together into a single list of consecutive n-tuples.  Imagine two input lists each being one side of a zipper: similar to the interlocking teeth of a zipper, the zip function interdigitates each element from each input list, one element at a time.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: [0, 1, 2, 3] zip ["a", "b", "c", "d"],
  b: [0, 1, 2, 3] zip "a",
  c: [0, 1, 2, 3] zip ["a", "b"]
}
----

.Output
[source,json,linenums]
----
{
  "a": [
    [0,"a"],
    [1,"b"],
    [2,"c"],
    [3,"d"]
    ],
  "b": [
    [0,"a"],
    [1,"a"],
    [2,"a"],
    [3,"a"]
  ],
  "c": [
    [0,"a"],
    [1,"b"]
  ]
}
----

Note that in example b, since only one element was provided in the second array, it was matched with every element of the first array. Also note that in example c, since the second array was shorter than the first, the output was only as long as the shortest of the two.


Here is another example of the zip function with more than two input lists.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
payload.list1 zip payload.list2 zip payload.list3
----


[.ex]
=====
[discrete.view]
=== Input: JSON

.Input
[source,json,linenums]
----
{
  "list1": ["a", "b", "c", "d"],
  "list2": [1, 2, 3],
  "list3": ["aa", "bb", "cc", "dd"],
  "list4": [["a", "b", "c"], [1, 2, 3, 4], ["aa", "bb", "cc", "dd"]]
}
----

[discrete.view]
=== Output: JSON

.Output
[source,json,linenums]
----
[
  [
    "a",
    1,
    "aa"
  ],
  [
    "b",
    2,
    "bb"
  ],
  [
    "c",
    3,
    "cc"
  ]
]
----
=====








== Unzip Array

.(':array') => ':array'

Performs the opposite function of <<zip arrays>>, that is: given a single array where each index contains an array with two elements, it outputs two separate arrays, each with one of the elements of the pair. This can also be scaled up, if the indexes in the provided array contain arrays with more than two elements, the output will contain as many arrays as there are elements for each index.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: unzip [[0,"a"],[1,"b"],[2,"c"],[3,"d"]],
  b: unzip [ [0,"a"], [1,"a"], [2,"a"], [3,"a"]],
  c: unzip [ [0,"a"], [1,"a","foo"], [2], [3,"a"]]
}
----

.Output
[source,json,linenums]
----
{
   "a":[
      [0, 1, 2, 3],
      ["a", "b", "c", "d"]
    ],
  "b": [
      [0,1,2,3],
      ["a","a","a","a"]
    ],
  "c": [
      [0,1,2,3]
    ]
}
----

Note even though example b can be considered the inverse function to the example b in <<zip array>>, the result is not analogous, since it returns an array of repeated elements instead of a single element. Also note that in example c, since the number of elements in each component of the original array is not consistent, the output only creates as many full arrays as it can, in this case just one.


== Replace

.(':string', ':regex', ':function') => ':string'

Replaces a section of a string for another, in accordance to a regular expression, and returns a modified string.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
b: "admin123" replace /(\d+)/ with "ID"
----

.Output
[source,json,linenums]
----
{
  "b": "adminID"
}
----

== Matches

.(':string', ':regex') => ':boolean'

Matches a string against a regular expression, and returns *true* or *false*.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
b: "admin123" matches /(\d+)/
----

.Output
[source,json,linenums]
----
{
  "b": false
}
----

[TIP]
For more advanced use cases where you need to output or conditionally process the matched value, see xref:dataweave-language-introduction.adoc#pattern-matching[Pattern Matching].

== Starts With

.(':string', ':string') => ':boolean'

Returns true or false depending on if a string starts with a provided substring.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: "Mariano" startsWith "Mar",
  b: "Mariano" startsWith "Em"
}
----

.Output
[source,json,linenums]
----
{
  "a": true,
  "b": false
}
----


== Ends With

.(':string', ':string') => ':boolean'

Returns true or false depending on if a string ends with a provided substring.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: "Mariano" endsWith "no",
  b: "Mariano" endsWith "to"
}
----

.Output
[source,json,linenums]
----
{
  "a": true,
  "b": false
}
----



== Find

.(':string', ':string')/.(':string', ':regex') => ':array'

Given a string, it returns the index position within the string at which a match was matched. If found in multiple parts of the string, it returns an array with the various idex positions at which it was found. You can either look for a simple string or a regular expression.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: "aabccde" find /(a).(b)(c.)d/,
  b: "aabccdbce" find "a",
  c: "aabccdbce" find "bc"
}
----


.Output
[source,json,linenums]
----
{
  "a": [[0,0,2,3]],
  "b": [0,1],
  "c": [2,6]
}
----


== Match

.(':string', ':regex') => ':array'

Match a string against a regular expression. Match returns an array that contains the entire matching expression, followed by all of the capture groups that match the provided regex.

It can be applied to the result of any evaluated expression, and can return any evaluated expression. See the Match operator in xref:dataweave-language-introduction.adoc[the DataWeave Language Introduction].


.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
  hello: "anniepoint@mulesoft.com" match /([a-z]*)@([a-z]*).com/
----

.Output
[source,json,linenums]
----
{
  "hello": [
    "anniepoint@mulesoft.com",
    "anniepoint",
    "mulesoft"
  ]
}
----

In the example above, we see that the search regular expression describes an email address. It contains two capture groups, what's before and what's after the @. The result is an array of three elements: the first is the whole email address, the second matches one of the capture groups, the third matches the other one.


== Scan

.(':string', ':regex') => ':array'

Returns an array with all of the matches in the given string. Each match is returned as an array that contains the complete match, as well as any capture groups there may be in your regular expression.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
  hello: "anniepoint@mulesoft.com,max@mulesoft.com" scan /([a-z]*)@([a-z]*).com/
----

.Output
[source,json,linenums]
----
{
  "hello": [
    [
      "anniepoint@mulesoft.com",
      "anniepoint",
      "mulesoft"
    ],
    [
      "max@mulesoft.com",
      "max",
      "mulesoft"
    ]
  ]
}
----

In the example above, we see that the search regular expression describes an email address. It contains two capture groups, what's before and what's after the @. The result is an array with two matches, as there are two email addresses in the input string. Each of these matches is an array of three elements, the first is the whole email address, the second matches one of the capture groups, the third matches the other one.

== Similar
.(':any', ':any') => ':boolean'

Evaluates if two values are similar, regardless of their type. For example, the string "1234" and the number 1234 aren't equal, but they are recognized as similar.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
    a: "1234" == 1234,
    b: "1234" ~= 1234,
    c: "true" == true,
    d: "true" ~= true
}
----

.Output
[source,json,linenums]
----
{
  "a": false,
  "b": true,
  "c": false,
  "d": true
}
----


== Upper
.(':string') => ':string'

Returns the provided string in uppercase characters.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  name: upper "mulesoft"
}
----

.Output
[source,json,linenums]
----
{
  "name": MULESOFT
}
----


== Lower
.(':string') => ':string'

Returns the provided string in lowercase characters.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  name: lower "MULESOFT"
}
----

.Output
[source,json,linenums]
----
{
  "name": mulesoft
}
----


== Camelize
.(':string') => ':string'

Returns the provided string in camel case.
All underscores are deleted, including any underscores at the beginning of the string.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: camelize "customer",
  b: camelize "customer_first_name",
  c: camelize "customer name",
  d: camelize "_name_starts_with_underscore"
}
----

.Output
[source,json,linenums]
----
{
  "a": "customer",
  "b": "customerFirstName",
  "c": "customer name",
  "d": "nameStartsWithUnderscore"
}
----

== Capitalize
.(':string') => ':string'

Returns the provided string with every word starting with a capital letter and no underscores. It also replaces underscores with spaces and puts a space before each capitalized word.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: capitalize "customer",
  b: capitalize "customer_first_name",
  c: capitalize "customer NAME",
  d: capitalize "customerName",
}
----

.Output
[source,json,linenums]
----
{
  "a": "Customer",
  "b": "Customer First Name",
  "c": "Customer Name",
  "d": "Customer Name"
}
----

== Dasherize
.(':string') => ':string'

Returns the provided string with every word separated by a dash.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: dasherize "customer",
  b: dasherize "customer_first_name",
  c: dasherize "customer NAME"
}
----

.Output
[source,json,linenums]
----
{
  "a": "customer",
  "b": "customer-first-name",
  "c": "customer-name"
}
----

== Underscore
.(':string') => ':string'

Returns the provided string with every word separated by an underscore.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: underscore "customer",
  b: underscore "customer-first-name",
  c: underscore "customer NAME"
}
----

.Output
[source,json,linenums]
----
{
  "a": "customer",
  "b": "customer_first_name",
  "c": "customer_NAME"
}
----



== Pluralize
.(':string') => ':string'

Returns the provided string transformed into its plural form.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: pluralize "box",
  b: pluralize "wife",
  c: pluralize "foot"
}
----

.Output
[source,json,linenums]
----
{
  "a": "boxes",
  "b": "wives",
  "c": "feet"
}
----

== Singularize
.(':string') => ':string'

Returns the provided string transformed into its singular form.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: singularize "boxes",
  b: singularize "wives",
  c: singularize "feet"
}
----

.Output
[source,json,linenums]
----
{
  "a": "box",
  "b": "wife",
  "c": "foot"
}
----

== Trim
.(':string') => ':string'

Removes any excess spaces at the start and end of a string.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  "a": trim "   my long text     "
}
----

.Output
[source,json,linenums]
----
{
  "a": "my long text"
}
----


== Substring
.(':string') => ':string'

Extracts a set of characters out of a string, based on the position that the first and last character of the desired substring occupy in the character array. If you use negative numbers, you can also inverse the order in which characters are set.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  "a": "abcdefg"[0..4],
  "b": "abcdefg"[-1..-4]
}
----

.Output
[source,json,linenums]
----
{
  "a": "abcde"
  "b": "gfed"
}
----





== Ordinalize
.(':number') => ':string'

Returns the provided numbers set as ordinals.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: ordinalize 1,
  b: ordinalize 8,
  c: ordinalize 103
}
----

.Output
[source,json,linenums]
----
{
  "a": "1st",
  "b": "8th",
  "c": "103rd"
}
----

== Basic Math Operations

=== Sum
.(':number', ':number') => ':number'

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/xml
---
plus : 2 + 2.5
----

=== Minus
.(':number', ':number') => ':number'

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/xml
---
minus : 2.5 - 2
----

=== Multiply
.(':number', ':number') => ':number'

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/xml
---
multiply : 2.5 * 2
----

=== Division
.(':number', ':number') => ':number'

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/xml
---
division : 10 / 2
----

== Max

.(':array')/(':object') => ':number'

Returns the highest number in an array or object.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: max [1..1000],
  b: max [1, 2, 3],
  d: max [1.5, 2.5, 3.5]
}
----

.Output
[source,json,linenums]
----
{
  "a": 1000,
  "b": 3,
  "d": 3.5
}
----

== Min

.(':array')/(':object') => ':number'

Returns the lowest number in an array or object.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: min [1..1000],
  b: min [1, 2, 3],
  d: min [1.5, 2.5, 3.5]
}
----

.Output
[source,json,linenums]
----
{
  "a": 1,
  "b": 1,
  "d": 1.5
}
----

== Round

.(':number') => ':number'

Rounds the value of a number to the nearest integer

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: round 1.2,
  b: round 4.6,
  c: round 3.5
}
----

.Output
[source,json,linenums]
----
{
  "a": 1,
  "b": 5,
  "c": 4
}
----

== Sqrt

.(':number') => ':number'

Returns the square root of the provided number

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: sqrt 4,
  b: sqrt 25,
  c: sqrt 100
}
----

.Output
[source,json,linenums]
----
{
  "a": 2.0,
  "b": 5.0,
  "c": 10.0
}
----

== Pow

.(':number', ':number') => ':number'

Returns the result of the first number `a` to the power of the number following the `pow` operator.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: 2 pow 3,
  b: 3 pow 2,
  c: 7 pow 3
}
----

.Output
[source,json,linenums]
----
{
  "a": 8,
  "b": 9,
  "c": 343
}
----

== Ceil

.(':number') => ':number'

Rounds a number upwards, returning the first full number above than the one provided.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---

{
  a: ceil 1.5,
  b: ceil 2.2,
  c: ceil 3
}
----

.Output
[source,json,linenums]
----
{
  "a": 2,
  "b": 3,
  "c": 3
}
----

== Floor

.(':number') => ':number'

Rounds a number downwards, returning the first full number below than the one provided.


.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: floor 1.5,
  b: floor 2.2,
  c: floor 3
}
----

.Output
[source,json,linenums]
----
{
  "a": 1,
  "b": 2,
  "c": 3
}
----

== Abs

.(':number') => ':number'

Returns the absolute value of a number,

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: abs -2,
  b: abs 2.5,
  c: abs -3.4,
  d: abs 3
}
----

.Output
[source,json,linenums]
----
{
  "a": 2,
  "b": 2.5,
  "c": 3.4,
  "d": 3
}
----

== Mod

.(':number', ':number') => ':number'

Returns the remainder after division of the first number by the second one

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: 3 mod 2,
  b: 4 mod 2,
  c: 2.2 mod 2
}
----

.Output
[source,json,linenums]
----
{
  "a": 1,
  "b": 0,
  "c": 0.2
}
----

== Now

Returns a datetime object with the current date and time.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  current_time: now
}
----

.Output
[source,json,linenums]
----
{
  "current_time": "2016-10-20T17:15:06.196Z"
}
----


== Date Time Operations

There are several operators that deal with xref:dataweave-types.adoc#dates[date related types], which include date, time, localtime, datetime, localdatetime, period, timezone.

=== Get Time Unit

.(':date')/(':time')/(':localtime')/(':datetime')/(':localdatetime')/(':period') => (':date')/(':time')/(':localtime')/(':period')

You can extract a particular time unit from any date related type as shown below:

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: |2003-10-01|.day,
  b: |2003-10-01|.month,
  c: |2003-10-01|.year,
  d: |2003-10-01T23:57:59Z|.hour,
  e: |2003-10-01T23:57:59Z|.minutes,
  f: |2003-10-01T23:57:59Z|.seconds,
  g: |2003-10-01T23:57:59-03:00|.offsetSeconds,
  h: |23:57:59Z|.hour,
  i: |23:57:59.700|.nanoseconds,
  j: |23:57:59.700|.milliseconds,
  k: |2003-10-01T23:57:59Z|.dayOfWeek,
  l: |2003-10-01T23:57:59Z|.dayOfYear,
  m: |P3Y2M10D|.years
}
----

.Output
[source,json,linenums]
----
{
  "a": 1,
  "b": 10,
  "c": 2003,
  "d": 23,
  "e": 57,
  "f": 59,
  "g": -10800,
  "h": 23,
  "i": 700000000,
  "j": 700,
  "k": 3,
  "l": 274,
  "m": 3
}
----



=== Shift Time Zone

.(':datetime', ':timezone') => ':datetime'

Shift a date time to the specified timezone.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
a: |2014-01-01T14:00-03:00| >> |-08:00|
----

.Output
[source,json,linenums]
----
{
  "a": "2014-01-01T09:00-08:00"
}
----

=== Append Time

.(':date', ':time')/(':date', ':localtime')/(':time', ':date')/(':localtime', ':date') => (':localtime')/(':datetime')/(':localdatetime')

You can append a date to a time (or localtime) object so as to provide a more precise value.


.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: |2003-10-01| ++ |23:57:59|,
  b: |2003-10-01| ++ |23:57:59Z|
}

----

.Output
[source,json,linenums]
----
{
    "a": "2003-10-01T23:57:59",
    "b": "2003-10-01T23:57:59Z"
}
----


Note that the order in which the two objects are appended is irrelevant, so logically a ':date' + ':time'  will result in the same as a '#:time' + ':date'.


=== Append Time Zone

.(':datetime', ':timezone')/(':time', ':timezone')/(':localtime', ':timezone')/(':localdatetime', ':timezone') => (':localtime')/(':localdatetime')

Appends a time zone to a date type value.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
a: |2003-10-01T23:57:59| ++ |-03:00|
----

.Output
[source,json,linenums]
----
{
  "a": "2003-10-01T23:57:59-03:00"
}
----


=== Adding a Period of Time

.(':time', ':period')/(':datetime', ':period')/(':localtime', ':period')/(':localdatetime', ':period') => (':date')/(':time')/(':localtime')/(':datetime')/(':localdatetime')

Add or subtract a period of time from a given date or time type object.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
a: |2003-10-01T23:57:59Z| + |P1Y|
----

.Output
[source,json,linenums]
----
{
  "a": "2004-10-01T23:57:59Z"
}
----

=== Subtracting a Period of Time

.(':time', ':period')/(':datetime', ':period')/(':localtime', ':period')/(':localdatetime', ':period') => (':date')/(':time')/(':localtime')/(':datetime')/(':localdatetime')

The same logically applies to subtracting time periods from a date or time type object.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: |2003-10-01| - |P1Y|,
  b: |2003-10-01T23:57:59Z| - |P1Y|
}
----

.Output
[source,json,linenums]
----
{
  "a": "2002-10-01",
  "b": "2002-10-01T23:57:59Z"
}
----

Note that when a subtraction operation includes a time object and a period, the order in which both elements are placed is indiferent since it would be impossible to subtract a date from a period, so `|2003-10-01| - |P1Y|` returns the same as `|P1Y| - |2003-10-01|`.


=== Subtracting two Dates

.(':date', ':date')/(':datetime', ':datetime')/('#:time', ':time')/(':localtime', ':localtime')/(':localdatetime', ':localdatetime') => ':period'

When subtracting one date or time type object from another, what we logically get is the difference between these times expressed as a time period.

.Transform
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
---
{
  a: |23:59:56-03:00| - |22:59:56-00:00|,
  b: |2003-10-01| - |2002-09-23|
}
----

.Output
[source,json,linenums]
----
{
  "a": "PT-4H",
  "b": "P-1Y-8D"
}
----

=== Date Coercion
.(':any', ':type') ':any'

You can change the format of a date to fit another standard, see <<Coerce to date>>.



== Next Steps

* For a high level overview about the language, see xref:dataweave-language-introduction.adoc[DataWeave Language Introduction]
* For a listing and details about all of the types you can use, see xref:dataweave-types.adoc[DataWeave Types]
* For details on how to create and use your own functions, see xref:dataweave-types.adoc#functions-and-lambdas[Functions and Lambdas]
* View complete example projects that use DataWeave in the https://www.anypoint.mulesoft.com/exchange/?search=dataweave[Anypoint Exchange]

== See Also

* xref:dataweave-quickstart.adoc[DataWeave quickstart guide]
* xref:6@studio::transform-message-component-concept-studio.adoc[About Transform Message Component]
* xref:dataweave-language-introduction.adoc[DataWeave Language Introduction]
* xref:dataweave-types.adoc[DataWeave Types]
* xref:dataweave-formats.adoc[DataWeave Formats]
* xref:dataweave-selectors.adoc[DataWeave Selectors]
* xref:dataweave-memory-management.adoc[DataWeave Memory Management]
* xref:dataweave-examples.adoc[DataWeave Examples]
* xref:mel-dataweave-functions.adoc[MEL DataWeave Functions]
